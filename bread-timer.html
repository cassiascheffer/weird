<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bread Timer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #eee;
      padding: 20px;
    }
    .container { max-width: 600px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 10px; color: #f5d799; }
    .toggle-row {
      display: flex; justify-content: center; gap: 20px;
      margin-bottom: 20px; flex-wrap: wrap;
    }
    .toggle { display: flex; align-items: center; gap: 8px; cursor: pointer; }
    .toggle input { width: 18px; height: 18px; }
    .step {
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
      border-left: 4px solid #555;
      transition: all 0.3s;
    }
    .step.active { border-left-color: #f5d799; background: rgba(245,215,153,0.1); }
    .step.completed { opacity: 0.5; border-left-color: #4ade80; }
    .step-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .step-title { font-size: 1.2em; font-weight: 600; }
    .step-num { background: #f5d799; color: #1a1a2e; padding: 4px 12px; border-radius: 20px; font-weight: 700; }
    .step-content { color: #bbb; line-height: 1.6; margin-bottom: 15px; }
    .ingredients { background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; margin: 10px 0; }
    .ingredients li { margin-left: 20px; margin-bottom: 4px; }
    .timer-display {
      font-size: 2.5em; font-weight: 700; text-align: center;
      font-family: monospace; color: #f5d799; margin: 10px 0;
    }
    .fold-indicator {
      text-align: center; font-size: 1.3em; margin: 10px 0;
      padding: 10px; background: rgba(245,215,153,0.2); border-radius: 8px;
    }
    .fold-dots { display: flex; justify-content: center; gap: 10px; margin-top: 8px; }
    .fold-dot {
      width: 24px; height: 24px; border-radius: 50%;
      background: #555; display: flex; align-items: center;
      justify-content: center; font-weight: 700; font-size: 0.8em;
    }
    .fold-dot.done { background: #4ade80; color: #000; }
    .fold-dot.current { background: #f5d799; color: #000; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
    .btn {
      padding: 12px 24px; border: none; border-radius: 8px;
      font-size: 1em; cursor: pointer; font-weight: 600; transition: all 0.2s;
    }
    .btn-primary { background: #f5d799; color: #1a1a2e; }
    .btn-primary:hover { background: #ffedc2; }
    .btn-secondary { background: #555; color: #eee; }
    .btn-secondary:hover { background: #666; }
    .btn-danger { background: #ef4444; color: #fff; }
    .btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .alert {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #f5d799; color: #1a1a2e; padding: 40px;
      border-radius: 16px; text-align: center; z-index: 1000;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5); animation: shake 0.5s;
    }
    @keyframes shake {
      0%, 100% { transform: translate(-50%, -50%) rotate(0); }
      25% { transform: translate(-50%, -50%) rotate(-2deg); }
      75% { transform: translate(-50%, -50%) rotate(2deg); }
    }
    .alert h2 { font-size: 1.8em; margin-bottom: 15px; }
    .alert p { font-size: 1.2em; margin-bottom: 20px; }
    .overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7); z-index: 999;
    }
    .hidden { display: none !important; }
    .progress-bar {
      height: 6px; background: #333; border-radius: 3px; margin-top: 10px; overflow: hidden;
    }
    .progress-fill { height: 100%; background: #f5d799; transition: width 1s linear; }
    .reset-section { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #333; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üçû Bread Baking Timer</h1>
    
    <div class="toggle-row">
      <label class="toggle">
        <input type="checkbox" id="screenToggle">
        <span>Keep Screen On</span>
      </label>
      <label class="toggle">
        <input type="checkbox" id="soundToggle" checked>
        <span>Sound On</span>
      </label>
      <label class="toggle">
        <input type="checkbox" id="scrubberToggle" onchange="renderSteps()">
        <span>Dev Mode</span>
      </label>
    </div>

    <div id="steps"></div>
    
    <div class="reset-section">
      <button class="btn btn-danger" onclick="resetAll()">Reset Everything</button>
    </div>
  </div>

  <div id="overlay" class="overlay hidden"></div>
  <div id="alert" class="alert hidden">
    <h2 id="alertTitle"></h2>
    <p id="alertMsg"></p>
    <button class="btn btn-primary" onclick="dismissAlert()">Got it!</button>
  </div>

<script>
const STORAGE_KEY = 'breadTimerState';
const SAVE_INTERVAL = 5000;

const STEPS = [
  { id: 1, title: 'Autolyse', duration: 1500, description: 'Mix flours and water, rest 25 minutes.',
    ingredients: ['600g white flour', '400g whole wheat flour', '800g water (90-95¬∞F / 32-35¬∞C)'],
    details: 'Mix flours by hand in a 12-quart tub. Add warm water and mix just until incorporated. Cover and rest.' },
  { id: 2, title: 'Mix', duration: 0, description: 'Add salt and yeast, use pincer method.',
    ingredients: ['22g fine sea salt', '3g instant dry yeast'],
    details: 'Sprinkle salt and yeast over dough. Wet your hand, fold dough 4 times enclosing additions. Use pincer cuts (thumb/forefinger) 5-6 times, then fold. Repeat until integrated. Target temp: 77-78¬∞F (25-26¬∞C).' },
  { id: 3, title: 'Bulk Rise & Folds', duration: 18000, foldInterval: 1800, foldCount: 4,
    description: 'Rise ~5 hours total. Fold every 30 min for first 2 hours.',
    details: 'Do all 4 folds in the first 2 hours. When dough triples (~5 hours after mixing), it\'s ready to divide.' },
  { id: 4, title: 'Divide', duration: 0, description: 'Divide dough into 2 equal pieces.',
    details: 'Flour surface. Gently tip dough out without tearing. Cut into 2 equal pieces with dough knife.' },
  { id: 5, title: 'Shape', duration: 0, description: 'Shape into balls, place in proofing baskets.',
    details: 'Dust 2 proofing baskets with flour. Shape each piece into a medium-tight ball. Place seam side down in baskets.' },
  { id: 6, title: 'Overnight Proof', duration: 46800, reminderAt: 43200, description: 'Refrigerate 12-14 hours.',
    details: 'Place each basket in a plastic bag and refrigerate overnight. Loaves go straight from fridge to oven. Timer reminds you at 12 hours, optimal window is 12-14 hours.' },
  { id: 7, title: 'Preheat', duration: 2700, description: 'Preheat Dutch ovens at 475¬∞F for 45 min.',
    details: 'Put rack in middle of oven. Place Dutch oven(s) with lids on rack. Preheat to 475¬∞F (245¬∞C) for at least 45 minutes. Start this step 45 min before you want to bake!' },
  { id: 8, title: 'Bake', duration: 3300, phases: [
      { name: 'Covered', at: 0, duration: 1800 },
      { name: 'Remove Lid', at: 1800, duration: 1500 }
    ], description: 'Bake covered 30 min, then uncovered 20-25 min.',
    details: 'Invert loaf onto counter (seam side up in pot). Bake covered 30 min at 475¬∞F, then remove lid and bake 20-25 min until dark brown. Cool 20 min before slicing.' }
];

let state = { currentStep: 0, elapsed: 0, foldsDone: 0, running: false, startedAt: null, reminderFired: false, phasesAlerted: {} };
let timer = null;
let wakeLock = null;
let audioCtx = null;

function loadState() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      if (parsed.startedAt && parsed.running) {
        const now = Date.now();
        const realElapsed = Math.floor((now - parsed.startedAt) / 1000);
        parsed.elapsed = realElapsed;
      }
      state = { ...state, ...parsed };
    }
  } catch(e) { console.log('No saved state'); }
}

function saveState() {
  try {
    const toSave = { ...state };
    if (state.running) toSave.startedAt = Date.now() - (state.elapsed * 1000);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
  } catch(e) {}
}

function formatTime(s) {
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  if (h > 0) return `${h}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  return `${m}:${String(sec).padStart(2,'0')}`;
}

function playBeep(times = 3) {
  if (!document.getElementById('soundToggle').checked) return;
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let t = audioCtx.currentTime;
  for (let i = 0; i < times; i++) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = 880;
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.3, t + i * 0.3);
    gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.3 + 0.2);
    osc.start(t + i * 0.3);
    osc.stop(t + i * 0.3 + 0.25);
  }
}

function showAlert(title, msg) {
  document.getElementById('alertTitle').textContent = title;
  document.getElementById('alertMsg').textContent = msg;
  document.getElementById('alert').classList.remove('hidden');
  document.getElementById('overlay').classList.remove('hidden');
  playBeep(5);
}

function dismissAlert() {
  document.getElementById('alert').classList.add('hidden');
  document.getElementById('overlay').classList.add('hidden');
}

function renderSteps() {
  const container = document.getElementById('steps');
  container.innerHTML = '';
  STEPS.forEach((step, idx) => {
    const div = document.createElement('div');
    div.className = 'step' + (idx === state.currentStep ? ' active' : '') + (idx < state.currentStep ? ' completed' : '');
    div.id = 'step-' + idx;
    
    let html = `<div class="step-header">
      <span class="step-title">${step.title}</span>
      <span class="step-num">${step.id}</span>
    </div>
    <div class="step-content">${step.description}</div>`;
    
    if (step.ingredients) {
      html += `<ul class="ingredients">${step.ingredients.map(i => `<li>${i}</li>`).join('')}</ul>`;
    }
    html += `<div class="step-content" style="font-size:0.9em">${step.details}</div>`;
    
    if (idx === state.currentStep) {
      if (step.duration > 0) {
        html += `<div class="timer-display" id="timerDisplay">${formatTime(step.duration - state.elapsed)}</div>`;
        html += `<div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:${(state.elapsed/step.duration)*100}%"></div></div>`;
        if (document.getElementById('scrubberToggle')?.checked) {
          html += `<input type="range" id="scrubber" min="0" max="${step.duration}" value="${state.elapsed}" style="width:100%;margin-top:10px;cursor:pointer" oninput="scrubTo(this.value)">`;
          html += `<div style="text-align:center;font-size:0.8em;color:#888;margin-top:4px">‚è© Scrub timer (testing)</div>`;
        }
      }
      if (step.foldCount) {
        html += `<div class="fold-indicator">
          <div>Fold ${Math.min(state.foldsDone + 1, step.foldCount)} of ${step.foldCount}</div>
          <div class="fold-dots">${[1,2,3,4].map(n => 
            `<div class="fold-dot ${n <= state.foldsDone ? 'done' : n === state.foldsDone + 1 ? 'current' : ''}">${n}</div>`
          ).join('')}</div>
        </div>`;
      }
      if (step.phases) {
        html += `<div class="fold-indicator" id="phaseIndicator"></div>`;
      }
      if (step.reminderAt) {
        const inWindow = state.elapsed >= step.reminderAt;
        html += `<div class="fold-indicator" style="background:${inWindow ? 'rgba(74,222,128,0.2)' : 'rgba(245,215,153,0.2)'}">
          ${inWindow ? '‚úì In optimal window (12-14 hours)' : 'Waiting for 12-hour mark...'}
        </div>`;
      }
      html += `<div class="btn-row" style="margin-top:15px">`;
      if (step.duration > 0) {
        if (!state.running) {
          html += `<button class="btn btn-primary" onclick="startTimer()">Start Timer</button>`;
        } else {
          html += `<button class="btn btn-secondary" onclick="pauseTimer()">Pause</button>`;
        }
      }
      html += `<button class="btn btn-secondary" onclick="completeStep()">Complete Step</button>`;
      if (idx > 0) html += `<button class="btn btn-secondary" onclick="prevStep()">Back</button>`;
      html += `</div>`;
    }
    
    div.innerHTML = html;
    container.appendChild(div);
  });
}

function tick() {
  state.elapsed++;
  const step = STEPS[state.currentStep];
  
  if (step.foldInterval && state.foldsDone < step.foldCount) {
    const nextFoldAt = (state.foldsDone + 1) * step.foldInterval;
    if (state.elapsed >= nextFoldAt) {
      state.foldsDone++;
      showAlert(`Time for Fold ${state.foldsDone}!`, 'Stretch and fold the dough now.');
    }
  }
  
  if (step.reminderAt && !state.reminderFired && state.elapsed >= step.reminderAt) {
    state.reminderFired = true;
    showAlert('12 Hours Reached!', 'Loaves are now in optimal proofing window (12-14 hours). You can bake anytime now!');
  }
  
  if (step.phases) {
    for (const phase of step.phases) {
      if (!state.phasesAlerted) state.phasesAlerted = {};
      if (state.elapsed >= phase.at && !state.phasesAlerted[phase.name]) {
        state.phasesAlerted[phase.name] = true;
        if (phase.at > 0) {
          showAlert(`${phase.name}!`, phase.name === 'Remove Lid' ? 'Remove the Dutch oven lid now. Bake 20-25 more min until dark brown.' : phase.name);
        }
      }
    }
  }
  
  if (step.duration > 0 && state.elapsed >= step.duration) {
    pauseTimer();
    showAlert('Timer Complete!', `${step.title} is done. Move to the next step.`);
  }
  
  const display = document.getElementById('timerDisplay');
  const fill = document.getElementById('progressFill');
  if (display) display.textContent = formatTime(Math.max(0, step.duration - state.elapsed));
  if (fill) fill.style.width = `${Math.min(100, (state.elapsed / step.duration) * 100)}%`;
  
  renderPhaseIndicator();
}

function startTimer() {
  state.running = true;
  state.startedAt = Date.now() - (state.elapsed * 1000);
  timer = setInterval(tick, 1000);
  saveState();
  renderSteps();
}

function pauseTimer() {
  state.running = false;
  clearInterval(timer);
  timer = null;
  saveState();
  renderSteps();
}

function completeStep() {
  pauseTimer();
  if (state.currentStep < STEPS.length - 1) {
    state.currentStep++;
    state.elapsed = 0;
    state.foldsDone = 0;
    state.running = false;
    state.reminderFired = false;
    state.phasesAlerted = {};
    saveState();
    renderSteps();
    document.getElementById('step-' + state.currentStep).scrollIntoView({ behavior: 'smooth', block: 'center' });
  } else {
    showAlert('üéâ Congratulations!', 'Your bread is done! Let it cool before slicing.');
  }
}

function prevStep() {
  pauseTimer();
  if (state.currentStep > 0) {
    state.currentStep--;
    state.elapsed = 0;
    state.foldsDone = 0;
    state.reminderFired = false;
    state.phasesAlerted = {};
    saveState();
    renderSteps();
  }
}

function scrubTo(val) {
  const newElapsed = parseInt(val);
  const step = STEPS[state.currentStep];
  
  // Reset alerts if scrubbing backward
  if (newElapsed < state.elapsed) {
    if (step.foldInterval) {
      state.foldsDone = Math.floor(newElapsed / step.foldInterval);
      if (state.foldsDone > step.foldCount) state.foldsDone = step.foldCount;
    }
    if (step.reminderAt && newElapsed < step.reminderAt) {
      state.reminderFired = false;
    }
    if (step.phases) {
      state.phasesAlerted = {};
      for (const phase of step.phases) {
        if (newElapsed >= phase.at) state.phasesAlerted[phase.name] = true;
      }
    }
  } else {
    // Scrubbing forward - update fold count without alerts
    if (step.foldInterval) {
      state.foldsDone = Math.floor(newElapsed / step.foldInterval);
      if (state.foldsDone > step.foldCount) state.foldsDone = step.foldCount;
    }
    if (step.reminderAt && newElapsed >= step.reminderAt) {
      state.reminderFired = true;
    }
    if (step.phases) {
      for (const phase of step.phases) {
        if (newElapsed >= phase.at) state.phasesAlerted[phase.name] = true;
      }
    }
  }
  
  state.elapsed = newElapsed;
  state.startedAt = Date.now() - (state.elapsed * 1000);
  saveState();
  
  const display = document.getElementById('timerDisplay');
  const fill = document.getElementById('progressFill');
  if (display) display.textContent = formatTime(Math.max(0, step.duration - state.elapsed));
  if (fill) fill.style.width = `${Math.min(100, (state.elapsed / step.duration) * 100)}%`;
  
  renderPhaseIndicator();
  renderSteps();
}

function renderPhaseIndicator() {
  const step = STEPS[state.currentStep];
  const el = document.getElementById('phaseIndicator');
  if (!el || !step.phases) return;
  
  let currentPhase = step.phases[0];
  for (const p of step.phases) {
    if (state.elapsed >= p.at) currentPhase = p;
  }
  
  const phaseEnd = currentPhase.at + currentPhase.duration;
  const phaseRemaining = Math.max(0, phaseEnd - state.elapsed);
  
  el.innerHTML = `<div style="font-weight:600">${currentPhase.name}</div>
    <div style="font-size:0.9em;margin-top:4px">${formatTime(phaseRemaining)} remaining in this phase</div>
    <div class="fold-dots" style="margin-top:8px">
      ${step.phases.map(p => `<div class="fold-dot ${state.elapsed >= p.at ? 'done' : ''}" style="width:auto;padding:4px 10px;border-radius:12px">${p.name}</div>`).join('')}
    </div>`;
}

function resetAll() {
  if (confirm('Reset all progress?')) {
    pauseTimer();
    state = { currentStep: 0, elapsed: 0, foldsDone: 0, running: false, startedAt: null, reminderFired: false, phasesAlerted: {} };
    localStorage.removeItem(STORAGE_KEY);
    renderSteps();
  }
}

async function toggleWakeLock(enable) {
  try {
    if (enable && 'wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
    } else if (wakeLock) {
      await wakeLock.release();
      wakeLock = null;
    }
  } catch(e) { console.log('Wake lock not supported'); }
}

document.getElementById('screenToggle').addEventListener('change', e => toggleWakeLock(e.target.checked));

setInterval(saveState, SAVE_INTERVAL);
loadState();
renderSteps();
if (state.running) startTimer();
</script>
</body>
</html>
